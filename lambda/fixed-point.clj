;;
;; 函数f的不动点是一个值x使得f(x) = x。例如，0和1是函数f(x) = x**2的不动点，
;; 因为0**2 = 0而1**2 = 1。鉴于一阶函数（在简单值比如整数上的函数）的不动点
;; 是个一阶值，高阶函数f的不动点是另一个函数g使得f(g) = g。那么，不动点算子是
;; 任何函数fix使得对于任何函数f都有 f(fix(f)) = fix(f).
;;
;; 在无类型lambda演算中众所周知的（可能是最简单的）不动点组合子叫做Y组合子。它是Haskell B. Curry发现的，定义为
;; Y = λf.(λx.f (x x)) (λx.f (x x))用一个例子函数g来展开它，我们可以看到上面这个函数是怎么成为一个不动点组合子的：
;; Y g = (λf.(λx. f (x x)) (λx. f (x x))) g
;;     = (λx. g (x x)) (λx. g (x x))            （λf的β-归约 - 应用主函数于g）
;;     = (λy. g (y y)) (λx. g (x x))            （α-转换 - 重命名约束变量）
;;     = g ((λx. g (x x)) (λx. g (x x)))        （λy的β-归约 - 应用左侧函数于右侧函数）
;;     = g (Y g)（Y的定义）
;;
;;
;;

(defn fac-gen [f]
    #(if (<= % 1) 1 (* % (f (dec %)))))

;; 根据定义得出的函数如下，但是它毫无用武之地，当把参数应用到它之上时，它将会进入无穷递归。
;; (defn y [f]
;;   ((fn [x] (f (x x)))
;;    (fn [x] (f (x x)))))
;;
;; 当该函数应用到f上时，当有
;; ((fn [x] (f (x x))) (fn [x] (f (x x)))))
;; let g = (fn [x] (f x x))
;; 上式等价于
;; (f (g g)) = (f ((fn [x] (f (x x))) g))
;;           = (f (f (g g)))
;; 由于此处总是eager load，故此函数会进入无穷递归。
;; 有没有办法让(f (x x))不展开呢? 可以，只需要加个lambda就可以使其变成lazy load。


(defn y1 [f]
  ((fn [x]
     #(f (x x)))
    (fn [x]
      #(f (x x)))))
;; 由于新增的lambda没有参数，故我们调用的函数也不能有参数，但是已经可以实现递归了，下面的例子会进入无穷递归。。
;; ((y1 (fn [f] (println :hello) (f))))

;; 让我们给他加入参数，以便做支持更多的调用场景。
(defn y [f]
  ((fn [x] (fn [n] ((f (x x)) n)))
    (fn [x] (fn [n] ((f (x x)) n)))))
(assert (= ((y fac-gen) 5) 120))


;; DRY，代码明显重复，让我们去除重复代码。
(defn Y [f]
  ((fn [g] (g g))
    (fn [x] (fn [args] ((f (x x)) args)))))
(assert (= ((Y fac-gen) 5) 120))
;;
;; 让我们来证明下，我们的y确实是一个通用的不动点组合子。
;;
;; Y = λf.(λx.λn.f (x x) n) (λx.λn.f (x x) n)
;; Y g n  = (λf.(λx.λn.f (x x) n) (λx.λn.f (x x) n)) g n
;;        = (λx.λn.g (x x) n) (λx.λn.g (x x) n) n
;;        = (λy.λm.g (y y) m) (λx.λn.g (x x) n) n
;;        = (λm.g ((λx.λn.g (x x) n) (λx.λn.g (x x) n)) m) n
;;        = (λm.g (Y g) m) n
;;        = g (Y g) n
;;